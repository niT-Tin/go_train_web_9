// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.3
// source: train.proto

// import "google/protobuf/empty.proto";

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Train_GetTrainDailyList_FullMethodName       = "/proto.Train/GetTrainDailyList"
	Train_GetTrainDaily_FullMethodName           = "/proto.Train/GetTrainDaily"
	Train_GetTrainList_FullMethodName            = "/proto.Train/GetTrainList"
	Train_GetTrain_FullMethodName                = "/proto.Train/GetTrain"
	Train_CreateTrain_FullMethodName             = "/proto.Train/CreateTrain"
	Train_UpdateTrain_FullMethodName             = "/proto.Train/UpdateTrain"
	Train_DeleteTrain_FullMethodName             = "/proto.Train/DeleteTrain"
	Train_GetTrainDailyListByDate_FullMethodName = "/proto.Train/GetTrainDailyListByDate"
	Train_GetAllTrain_FullMethodName             = "/proto.Train/GetAllTrain"
	Train_GenerateTrainDaily_FullMethodName      = "/proto.Train/GenerateTrainDaily"
)

// TrainClient is the client API for Train service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainClient interface {
	GetTrainDailyList(ctx context.Context, in *TrainDailyPageInfo, opts ...grpc.CallOption) (*TrainDailyListResponse, error)
	GetTrainDaily(ctx context.Context, in *TrainDailyRequest, opts ...grpc.CallOption) (*TrainDailyResponse, error)
	GetTrainList(ctx context.Context, in *TrainPageInfo, opts ...grpc.CallOption) (*TrainListResponse, error)
	GetTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error)
	CreateTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error)
	UpdateTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error)
	DeleteTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error)
	GetTrainDailyListByDate(ctx context.Context, in *TrainDailyPageInfo, opts ...grpc.CallOption) (*TrainDailyListResponse, error)
	GetAllTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainListResponse, error)
	GenerateTrainDaily(ctx context.Context, in *TrainDailyRequest, opts ...grpc.CallOption) (*TrainListResponse, error)
}

type trainClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainClient(cc grpc.ClientConnInterface) TrainClient {
	return &trainClient{cc}
}

func (c *trainClient) GetTrainDailyList(ctx context.Context, in *TrainDailyPageInfo, opts ...grpc.CallOption) (*TrainDailyListResponse, error) {
	out := new(TrainDailyListResponse)
	err := c.cc.Invoke(ctx, Train_GetTrainDailyList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) GetTrainDaily(ctx context.Context, in *TrainDailyRequest, opts ...grpc.CallOption) (*TrainDailyResponse, error) {
	out := new(TrainDailyResponse)
	err := c.cc.Invoke(ctx, Train_GetTrainDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) GetTrainList(ctx context.Context, in *TrainPageInfo, opts ...grpc.CallOption) (*TrainListResponse, error) {
	out := new(TrainListResponse)
	err := c.cc.Invoke(ctx, Train_GetTrainList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) GetTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error) {
	out := new(TrainResponse)
	err := c.cc.Invoke(ctx, Train_GetTrain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) CreateTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error) {
	out := new(TrainResponse)
	err := c.cc.Invoke(ctx, Train_CreateTrain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) UpdateTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error) {
	out := new(TrainResponse)
	err := c.cc.Invoke(ctx, Train_UpdateTrain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) DeleteTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainResponse, error) {
	out := new(TrainResponse)
	err := c.cc.Invoke(ctx, Train_DeleteTrain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) GetTrainDailyListByDate(ctx context.Context, in *TrainDailyPageInfo, opts ...grpc.CallOption) (*TrainDailyListResponse, error) {
	out := new(TrainDailyListResponse)
	err := c.cc.Invoke(ctx, Train_GetTrainDailyListByDate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) GetAllTrain(ctx context.Context, in *TrainRequest, opts ...grpc.CallOption) (*TrainListResponse, error) {
	out := new(TrainListResponse)
	err := c.cc.Invoke(ctx, Train_GetAllTrain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainClient) GenerateTrainDaily(ctx context.Context, in *TrainDailyRequest, opts ...grpc.CallOption) (*TrainListResponse, error) {
	out := new(TrainListResponse)
	err := c.cc.Invoke(ctx, Train_GenerateTrainDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainServer is the server API for Train service.
// All implementations must embed UnimplementedTrainServer
// for forward compatibility
type TrainServer interface {
	GetTrainDailyList(context.Context, *TrainDailyPageInfo) (*TrainDailyListResponse, error)
	GetTrainDaily(context.Context, *TrainDailyRequest) (*TrainDailyResponse, error)
	GetTrainList(context.Context, *TrainPageInfo) (*TrainListResponse, error)
	GetTrain(context.Context, *TrainRequest) (*TrainResponse, error)
	CreateTrain(context.Context, *TrainRequest) (*TrainResponse, error)
	UpdateTrain(context.Context, *TrainRequest) (*TrainResponse, error)
	DeleteTrain(context.Context, *TrainRequest) (*TrainResponse, error)
	GetTrainDailyListByDate(context.Context, *TrainDailyPageInfo) (*TrainDailyListResponse, error)
	GetAllTrain(context.Context, *TrainRequest) (*TrainListResponse, error)
	GenerateTrainDaily(context.Context, *TrainDailyRequest) (*TrainListResponse, error)
	mustEmbedUnimplementedTrainServer()
}

// UnimplementedTrainServer must be embedded to have forward compatible implementations.
type UnimplementedTrainServer struct {
}

func (UnimplementedTrainServer) GetTrainDailyList(context.Context, *TrainDailyPageInfo) (*TrainDailyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainDailyList not implemented")
}
func (UnimplementedTrainServer) GetTrainDaily(context.Context, *TrainDailyRequest) (*TrainDailyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainDaily not implemented")
}
func (UnimplementedTrainServer) GetTrainList(context.Context, *TrainPageInfo) (*TrainListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainList not implemented")
}
func (UnimplementedTrainServer) GetTrain(context.Context, *TrainRequest) (*TrainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrain not implemented")
}
func (UnimplementedTrainServer) CreateTrain(context.Context, *TrainRequest) (*TrainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrain not implemented")
}
func (UnimplementedTrainServer) UpdateTrain(context.Context, *TrainRequest) (*TrainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTrain not implemented")
}
func (UnimplementedTrainServer) DeleteTrain(context.Context, *TrainRequest) (*TrainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrain not implemented")
}
func (UnimplementedTrainServer) GetTrainDailyListByDate(context.Context, *TrainDailyPageInfo) (*TrainDailyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainDailyListByDate not implemented")
}
func (UnimplementedTrainServer) GetAllTrain(context.Context, *TrainRequest) (*TrainListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTrain not implemented")
}
func (UnimplementedTrainServer) GenerateTrainDaily(context.Context, *TrainDailyRequest) (*TrainListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateTrainDaily not implemented")
}
func (UnimplementedTrainServer) mustEmbedUnimplementedTrainServer() {}

// UnsafeTrainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainServer will
// result in compilation errors.
type UnsafeTrainServer interface {
	mustEmbedUnimplementedTrainServer()
}

func RegisterTrainServer(s grpc.ServiceRegistrar, srv TrainServer) {
	s.RegisterService(&Train_ServiceDesc, srv)
}

func _Train_GetTrainDailyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainDailyPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GetTrainDailyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GetTrainDailyList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GetTrainDailyList(ctx, req.(*TrainDailyPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_GetTrainDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GetTrainDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GetTrainDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GetTrainDaily(ctx, req.(*TrainDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_GetTrainList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GetTrainList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GetTrainList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GetTrainList(ctx, req.(*TrainPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_GetTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GetTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GetTrain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GetTrain(ctx, req.(*TrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_CreateTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).CreateTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_CreateTrain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).CreateTrain(ctx, req.(*TrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_UpdateTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).UpdateTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_UpdateTrain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).UpdateTrain(ctx, req.(*TrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_DeleteTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).DeleteTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_DeleteTrain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).DeleteTrain(ctx, req.(*TrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_GetTrainDailyListByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainDailyPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GetTrainDailyListByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GetTrainDailyListByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GetTrainDailyListByDate(ctx, req.(*TrainDailyPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_GetAllTrain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GetAllTrain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GetAllTrain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GetAllTrain(ctx, req.(*TrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Train_GenerateTrainDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainServer).GenerateTrainDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Train_GenerateTrainDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainServer).GenerateTrainDaily(ctx, req.(*TrainDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Train_ServiceDesc is the grpc.ServiceDesc for Train service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Train_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Train",
	HandlerType: (*TrainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrainDailyList",
			Handler:    _Train_GetTrainDailyList_Handler,
		},
		{
			MethodName: "GetTrainDaily",
			Handler:    _Train_GetTrainDaily_Handler,
		},
		{
			MethodName: "GetTrainList",
			Handler:    _Train_GetTrainList_Handler,
		},
		{
			MethodName: "GetTrain",
			Handler:    _Train_GetTrain_Handler,
		},
		{
			MethodName: "CreateTrain",
			Handler:    _Train_CreateTrain_Handler,
		},
		{
			MethodName: "UpdateTrain",
			Handler:    _Train_UpdateTrain_Handler,
		},
		{
			MethodName: "DeleteTrain",
			Handler:    _Train_DeleteTrain_Handler,
		},
		{
			MethodName: "GetTrainDailyListByDate",
			Handler:    _Train_GetTrainDailyListByDate_Handler,
		},
		{
			MethodName: "GetAllTrain",
			Handler:    _Train_GetAllTrain_Handler,
		},
		{
			MethodName: "GenerateTrainDaily",
			Handler:    _Train_GenerateTrainDaily_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "train.proto",
}

const (
	Station_GetStationDailyList_FullMethodName       = "/proto.Station/GetStationDailyList"
	Station_GetStationDaily_FullMethodName           = "/proto.Station/GetStationDaily"
	Station_GetStationList_FullMethodName            = "/proto.Station/GetStationList"
	Station_GetStation_FullMethodName                = "/proto.Station/GetStation"
	Station_CreateStation_FullMethodName             = "/proto.Station/CreateStation"
	Station_UpdateStation_FullMethodName             = "/proto.Station/UpdateStation"
	Station_DeleteStation_FullMethodName             = "/proto.Station/DeleteStation"
	Station_GetStationDailyListByDate_FullMethodName = "/proto.Station/GetStationDailyListByDate"
	Station_GetAllStation_FullMethodName             = "/proto.Station/GetAllStation"
	Station_GenerateStationDaily_FullMethodName      = "/proto.Station/GenerateStationDaily"
)

// StationClient is the client API for Station service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StationClient interface {
	GetStationDailyList(ctx context.Context, in *StationDailyPageInfo, opts ...grpc.CallOption) (*StationDailyListResponse, error)
	GetStationDaily(ctx context.Context, in *StationDailyRequest, opts ...grpc.CallOption) (*StationDailyResponse, error)
	GetStationList(ctx context.Context, in *StationPageInfo, opts ...grpc.CallOption) (*StationListResponse, error)
	GetStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error)
	CreateStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error)
	UpdateStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error)
	DeleteStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error)
	GetStationDailyListByDate(ctx context.Context, in *StationDailyPageInfo, opts ...grpc.CallOption) (*StationDailyListResponse, error)
	GetAllStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationListResponse, error)
	GenerateStationDaily(ctx context.Context, in *StationDailyRequest, opts ...grpc.CallOption) (*StationListResponse, error)
}

type stationClient struct {
	cc grpc.ClientConnInterface
}

func NewStationClient(cc grpc.ClientConnInterface) StationClient {
	return &stationClient{cc}
}

func (c *stationClient) GetStationDailyList(ctx context.Context, in *StationDailyPageInfo, opts ...grpc.CallOption) (*StationDailyListResponse, error) {
	out := new(StationDailyListResponse)
	err := c.cc.Invoke(ctx, Station_GetStationDailyList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStationDaily(ctx context.Context, in *StationDailyRequest, opts ...grpc.CallOption) (*StationDailyResponse, error) {
	out := new(StationDailyResponse)
	err := c.cc.Invoke(ctx, Station_GetStationDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStationList(ctx context.Context, in *StationPageInfo, opts ...grpc.CallOption) (*StationListResponse, error) {
	out := new(StationListResponse)
	err := c.cc.Invoke(ctx, Station_GetStationList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error) {
	out := new(StationResponse)
	err := c.cc.Invoke(ctx, Station_GetStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) CreateStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error) {
	out := new(StationResponse)
	err := c.cc.Invoke(ctx, Station_CreateStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) UpdateStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error) {
	out := new(StationResponse)
	err := c.cc.Invoke(ctx, Station_UpdateStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) DeleteStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationResponse, error) {
	out := new(StationResponse)
	err := c.cc.Invoke(ctx, Station_DeleteStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStationDailyListByDate(ctx context.Context, in *StationDailyPageInfo, opts ...grpc.CallOption) (*StationDailyListResponse, error) {
	out := new(StationDailyListResponse)
	err := c.cc.Invoke(ctx, Station_GetStationDailyListByDate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetAllStation(ctx context.Context, in *StationRequest, opts ...grpc.CallOption) (*StationListResponse, error) {
	out := new(StationListResponse)
	err := c.cc.Invoke(ctx, Station_GetAllStation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GenerateStationDaily(ctx context.Context, in *StationDailyRequest, opts ...grpc.CallOption) (*StationListResponse, error) {
	out := new(StationListResponse)
	err := c.cc.Invoke(ctx, Station_GenerateStationDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StationServer is the server API for Station service.
// All implementations must embed UnimplementedStationServer
// for forward compatibility
type StationServer interface {
	GetStationDailyList(context.Context, *StationDailyPageInfo) (*StationDailyListResponse, error)
	GetStationDaily(context.Context, *StationDailyRequest) (*StationDailyResponse, error)
	GetStationList(context.Context, *StationPageInfo) (*StationListResponse, error)
	GetStation(context.Context, *StationRequest) (*StationResponse, error)
	CreateStation(context.Context, *StationRequest) (*StationResponse, error)
	UpdateStation(context.Context, *StationRequest) (*StationResponse, error)
	DeleteStation(context.Context, *StationRequest) (*StationResponse, error)
	GetStationDailyListByDate(context.Context, *StationDailyPageInfo) (*StationDailyListResponse, error)
	GetAllStation(context.Context, *StationRequest) (*StationListResponse, error)
	GenerateStationDaily(context.Context, *StationDailyRequest) (*StationListResponse, error)
	mustEmbedUnimplementedStationServer()
}

// UnimplementedStationServer must be embedded to have forward compatible implementations.
type UnimplementedStationServer struct {
}

func (UnimplementedStationServer) GetStationDailyList(context.Context, *StationDailyPageInfo) (*StationDailyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationDailyList not implemented")
}
func (UnimplementedStationServer) GetStationDaily(context.Context, *StationDailyRequest) (*StationDailyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationDaily not implemented")
}
func (UnimplementedStationServer) GetStationList(context.Context, *StationPageInfo) (*StationListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationList not implemented")
}
func (UnimplementedStationServer) GetStation(context.Context, *StationRequest) (*StationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStation not implemented")
}
func (UnimplementedStationServer) CreateStation(context.Context, *StationRequest) (*StationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStation not implemented")
}
func (UnimplementedStationServer) UpdateStation(context.Context, *StationRequest) (*StationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStation not implemented")
}
func (UnimplementedStationServer) DeleteStation(context.Context, *StationRequest) (*StationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStation not implemented")
}
func (UnimplementedStationServer) GetStationDailyListByDate(context.Context, *StationDailyPageInfo) (*StationDailyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationDailyListByDate not implemented")
}
func (UnimplementedStationServer) GetAllStation(context.Context, *StationRequest) (*StationListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllStation not implemented")
}
func (UnimplementedStationServer) GenerateStationDaily(context.Context, *StationDailyRequest) (*StationListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateStationDaily not implemented")
}
func (UnimplementedStationServer) mustEmbedUnimplementedStationServer() {}

// UnsafeStationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StationServer will
// result in compilation errors.
type UnsafeStationServer interface {
	mustEmbedUnimplementedStationServer()
}

func RegisterStationServer(s grpc.ServiceRegistrar, srv StationServer) {
	s.RegisterService(&Station_ServiceDesc, srv)
}

func _Station_GetStationDailyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationDailyPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationDailyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStationDailyList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationDailyList(ctx, req.(*StationDailyPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStationDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStationDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationDaily(ctx, req.(*StationDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStationList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStationList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationList(ctx, req.(*StationPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStation(ctx, req.(*StationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_CreateStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).CreateStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_CreateStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).CreateStation(ctx, req.(*StationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_UpdateStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).UpdateStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_UpdateStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).UpdateStation(ctx, req.(*StationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_DeleteStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).DeleteStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_DeleteStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).DeleteStation(ctx, req.(*StationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStationDailyListByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationDailyPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationDailyListByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetStationDailyListByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationDailyListByDate(ctx, req.(*StationDailyPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetAllStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetAllStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GetAllStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetAllStation(ctx, req.(*StationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GenerateStationDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GenerateStationDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Station_GenerateStationDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GenerateStationDaily(ctx, req.(*StationDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Station_ServiceDesc is the grpc.ServiceDesc for Station service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Station_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Station",
	HandlerType: (*StationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStationDailyList",
			Handler:    _Station_GetStationDailyList_Handler,
		},
		{
			MethodName: "GetStationDaily",
			Handler:    _Station_GetStationDaily_Handler,
		},
		{
			MethodName: "GetStationList",
			Handler:    _Station_GetStationList_Handler,
		},
		{
			MethodName: "GetStation",
			Handler:    _Station_GetStation_Handler,
		},
		{
			MethodName: "CreateStation",
			Handler:    _Station_CreateStation_Handler,
		},
		{
			MethodName: "UpdateStation",
			Handler:    _Station_UpdateStation_Handler,
		},
		{
			MethodName: "DeleteStation",
			Handler:    _Station_DeleteStation_Handler,
		},
		{
			MethodName: "GetStationDailyListByDate",
			Handler:    _Station_GetStationDailyListByDate_Handler,
		},
		{
			MethodName: "GetAllStation",
			Handler:    _Station_GetAllStation_Handler,
		},
		{
			MethodName: "GenerateStationDaily",
			Handler:    _Station_GenerateStationDaily_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "train.proto",
}

const (
	Ticket_DeleteTicket_FullMethodName   = "/proto.Ticket/DeleteTicket"
	Ticket_GetAllTicket_FullMethodName   = "/proto.Ticket/GetAllTicket"
	Ticket_GenerateTicket_FullMethodName = "/proto.Ticket/GenerateTicket"
	Ticket_GetTicketList_FullMethodName  = "/proto.Ticket/GetTicketList"
	Ticket_ReductTicket_FullMethodName   = "/proto.Ticket/ReductTicket"
	Ticket_RebackTicket_FullMethodName   = "/proto.Ticket/RebackTicket"
)

// TicketClient is the client API for Ticket service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TicketClient interface {
	// 有时间再说
	// rpc CreateTicket(TicketRequest) returns (TicketResponse);
	DeleteTicket(ctx context.Context, in *TicketRequest, opts ...grpc.CallOption) (*TicketResponse, error)
	GetAllTicket(ctx context.Context, in *TicketPageInfo, opts ...grpc.CallOption) (*TicketListResponse, error)
	GenerateTicket(ctx context.Context, in *TicketRequest, opts ...grpc.CallOption) (*TicketListResponse, error)
	GetTicketList(ctx context.Context, in *TicketRequest, opts ...grpc.CallOption) (*TicketListResponse, error)
	ReductTicket(ctx context.Context, in *BusinessRequest, opts ...grpc.CallOption) (*TicketResponse, error)
	RebackTicket(ctx context.Context, in *BusinessRequest, opts ...grpc.CallOption) (*TicketResponse, error)
}

type ticketClient struct {
	cc grpc.ClientConnInterface
}

func NewTicketClient(cc grpc.ClientConnInterface) TicketClient {
	return &ticketClient{cc}
}

func (c *ticketClient) DeleteTicket(ctx context.Context, in *TicketRequest, opts ...grpc.CallOption) (*TicketResponse, error) {
	out := new(TicketResponse)
	err := c.cc.Invoke(ctx, Ticket_DeleteTicket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketClient) GetAllTicket(ctx context.Context, in *TicketPageInfo, opts ...grpc.CallOption) (*TicketListResponse, error) {
	out := new(TicketListResponse)
	err := c.cc.Invoke(ctx, Ticket_GetAllTicket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketClient) GenerateTicket(ctx context.Context, in *TicketRequest, opts ...grpc.CallOption) (*TicketListResponse, error) {
	out := new(TicketListResponse)
	err := c.cc.Invoke(ctx, Ticket_GenerateTicket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketClient) GetTicketList(ctx context.Context, in *TicketRequest, opts ...grpc.CallOption) (*TicketListResponse, error) {
	out := new(TicketListResponse)
	err := c.cc.Invoke(ctx, Ticket_GetTicketList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketClient) ReductTicket(ctx context.Context, in *BusinessRequest, opts ...grpc.CallOption) (*TicketResponse, error) {
	out := new(TicketResponse)
	err := c.cc.Invoke(ctx, Ticket_ReductTicket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketClient) RebackTicket(ctx context.Context, in *BusinessRequest, opts ...grpc.CallOption) (*TicketResponse, error) {
	out := new(TicketResponse)
	err := c.cc.Invoke(ctx, Ticket_RebackTicket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TicketServer is the server API for Ticket service.
// All implementations must embed UnimplementedTicketServer
// for forward compatibility
type TicketServer interface {
	// 有时间再说
	// rpc CreateTicket(TicketRequest) returns (TicketResponse);
	DeleteTicket(context.Context, *TicketRequest) (*TicketResponse, error)
	GetAllTicket(context.Context, *TicketPageInfo) (*TicketListResponse, error)
	GenerateTicket(context.Context, *TicketRequest) (*TicketListResponse, error)
	GetTicketList(context.Context, *TicketRequest) (*TicketListResponse, error)
	ReductTicket(context.Context, *BusinessRequest) (*TicketResponse, error)
	RebackTicket(context.Context, *BusinessRequest) (*TicketResponse, error)
	mustEmbedUnimplementedTicketServer()
}

// UnimplementedTicketServer must be embedded to have forward compatible implementations.
type UnimplementedTicketServer struct {
}

func (UnimplementedTicketServer) DeleteTicket(context.Context, *TicketRequest) (*TicketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicket not implemented")
}
func (UnimplementedTicketServer) GetAllTicket(context.Context, *TicketPageInfo) (*TicketListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTicket not implemented")
}
func (UnimplementedTicketServer) GenerateTicket(context.Context, *TicketRequest) (*TicketListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateTicket not implemented")
}
func (UnimplementedTicketServer) GetTicketList(context.Context, *TicketRequest) (*TicketListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTicketList not implemented")
}
func (UnimplementedTicketServer) ReductTicket(context.Context, *BusinessRequest) (*TicketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReductTicket not implemented")
}
func (UnimplementedTicketServer) RebackTicket(context.Context, *BusinessRequest) (*TicketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebackTicket not implemented")
}
func (UnimplementedTicketServer) mustEmbedUnimplementedTicketServer() {}

// UnsafeTicketServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TicketServer will
// result in compilation errors.
type UnsafeTicketServer interface {
	mustEmbedUnimplementedTicketServer()
}

func RegisterTicketServer(s grpc.ServiceRegistrar, srv TicketServer) {
	s.RegisterService(&Ticket_ServiceDesc, srv)
}

func _Ticket_DeleteTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).DeleteTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ticket_DeleteTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).DeleteTicket(ctx, req.(*TicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ticket_GetAllTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).GetAllTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ticket_GetAllTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).GetAllTicket(ctx, req.(*TicketPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ticket_GenerateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).GenerateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ticket_GenerateTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).GenerateTicket(ctx, req.(*TicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ticket_GetTicketList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).GetTicketList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ticket_GetTicketList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).GetTicketList(ctx, req.(*TicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ticket_ReductTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BusinessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).ReductTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ticket_ReductTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).ReductTicket(ctx, req.(*BusinessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ticket_RebackTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BusinessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).RebackTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Ticket_RebackTicket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).RebackTicket(ctx, req.(*BusinessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Ticket_ServiceDesc is the grpc.ServiceDesc for Ticket service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Ticket_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Ticket",
	HandlerType: (*TicketServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteTicket",
			Handler:    _Ticket_DeleteTicket_Handler,
		},
		{
			MethodName: "GetAllTicket",
			Handler:    _Ticket_GetAllTicket_Handler,
		},
		{
			MethodName: "GenerateTicket",
			Handler:    _Ticket_GenerateTicket_Handler,
		},
		{
			MethodName: "GetTicketList",
			Handler:    _Ticket_GetTicketList_Handler,
		},
		{
			MethodName: "ReductTicket",
			Handler:    _Ticket_ReductTicket_Handler,
		},
		{
			MethodName: "RebackTicket",
			Handler:    _Ticket_RebackTicket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "train.proto",
}

const (
	Carriage_GetCarriageDailyList_FullMethodName       = "/proto.Carriage/GetCarriageDailyList"
	Carriage_GetCarriageDaily_FullMethodName           = "/proto.Carriage/GetCarriageDaily"
	Carriage_GetCarriageList_FullMethodName            = "/proto.Carriage/GetCarriageList"
	Carriage_GetCarriage_FullMethodName                = "/proto.Carriage/GetCarriage"
	Carriage_CreateCarriage_FullMethodName             = "/proto.Carriage/CreateCarriage"
	Carriage_UpdateCarriage_FullMethodName             = "/proto.Carriage/UpdateCarriage"
	Carriage_DeleteCarriage_FullMethodName             = "/proto.Carriage/DeleteCarriage"
	Carriage_GetCarriageDailyListByDate_FullMethodName = "/proto.Carriage/GetCarriageDailyListByDate"
	Carriage_GetAllCarriage_FullMethodName             = "/proto.Carriage/GetAllCarriage"
	Carriage_GenerateCarriageDaily_FullMethodName      = "/proto.Carriage/GenerateCarriageDaily"
)

// CarriageClient is the client API for Carriage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CarriageClient interface {
	GetCarriageDailyList(ctx context.Context, in *CarriageDailyPageInfo, opts ...grpc.CallOption) (*CarriageDailyListResponse, error)
	GetCarriageDaily(ctx context.Context, in *CarriageDailyRequest, opts ...grpc.CallOption) (*CarriageDailyResponse, error)
	GetCarriageList(ctx context.Context, in *CarriagePageInfo, opts ...grpc.CallOption) (*CarriageListResponse, error)
	GetCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error)
	CreateCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error)
	UpdateCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error)
	DeleteCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error)
	GetCarriageDailyListByDate(ctx context.Context, in *CarriageDailyPageInfo, opts ...grpc.CallOption) (*CarriageDailyListResponse, error)
	GetAllCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageListResponse, error)
	GenerateCarriageDaily(ctx context.Context, in *CarriageDailyRequest, opts ...grpc.CallOption) (*CarriageListResponse, error)
}

type carriageClient struct {
	cc grpc.ClientConnInterface
}

func NewCarriageClient(cc grpc.ClientConnInterface) CarriageClient {
	return &carriageClient{cc}
}

func (c *carriageClient) GetCarriageDailyList(ctx context.Context, in *CarriageDailyPageInfo, opts ...grpc.CallOption) (*CarriageDailyListResponse, error) {
	out := new(CarriageDailyListResponse)
	err := c.cc.Invoke(ctx, Carriage_GetCarriageDailyList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) GetCarriageDaily(ctx context.Context, in *CarriageDailyRequest, opts ...grpc.CallOption) (*CarriageDailyResponse, error) {
	out := new(CarriageDailyResponse)
	err := c.cc.Invoke(ctx, Carriage_GetCarriageDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) GetCarriageList(ctx context.Context, in *CarriagePageInfo, opts ...grpc.CallOption) (*CarriageListResponse, error) {
	out := new(CarriageListResponse)
	err := c.cc.Invoke(ctx, Carriage_GetCarriageList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) GetCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error) {
	out := new(CarriageResponse)
	err := c.cc.Invoke(ctx, Carriage_GetCarriage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) CreateCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error) {
	out := new(CarriageResponse)
	err := c.cc.Invoke(ctx, Carriage_CreateCarriage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) UpdateCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error) {
	out := new(CarriageResponse)
	err := c.cc.Invoke(ctx, Carriage_UpdateCarriage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) DeleteCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageResponse, error) {
	out := new(CarriageResponse)
	err := c.cc.Invoke(ctx, Carriage_DeleteCarriage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) GetCarriageDailyListByDate(ctx context.Context, in *CarriageDailyPageInfo, opts ...grpc.CallOption) (*CarriageDailyListResponse, error) {
	out := new(CarriageDailyListResponse)
	err := c.cc.Invoke(ctx, Carriage_GetCarriageDailyListByDate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) GetAllCarriage(ctx context.Context, in *CarriageRequest, opts ...grpc.CallOption) (*CarriageListResponse, error) {
	out := new(CarriageListResponse)
	err := c.cc.Invoke(ctx, Carriage_GetAllCarriage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carriageClient) GenerateCarriageDaily(ctx context.Context, in *CarriageDailyRequest, opts ...grpc.CallOption) (*CarriageListResponse, error) {
	out := new(CarriageListResponse)
	err := c.cc.Invoke(ctx, Carriage_GenerateCarriageDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CarriageServer is the server API for Carriage service.
// All implementations must embed UnimplementedCarriageServer
// for forward compatibility
type CarriageServer interface {
	GetCarriageDailyList(context.Context, *CarriageDailyPageInfo) (*CarriageDailyListResponse, error)
	GetCarriageDaily(context.Context, *CarriageDailyRequest) (*CarriageDailyResponse, error)
	GetCarriageList(context.Context, *CarriagePageInfo) (*CarriageListResponse, error)
	GetCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error)
	CreateCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error)
	UpdateCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error)
	DeleteCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error)
	GetCarriageDailyListByDate(context.Context, *CarriageDailyPageInfo) (*CarriageDailyListResponse, error)
	GetAllCarriage(context.Context, *CarriageRequest) (*CarriageListResponse, error)
	GenerateCarriageDaily(context.Context, *CarriageDailyRequest) (*CarriageListResponse, error)
	mustEmbedUnimplementedCarriageServer()
}

// UnimplementedCarriageServer must be embedded to have forward compatible implementations.
type UnimplementedCarriageServer struct {
}

func (UnimplementedCarriageServer) GetCarriageDailyList(context.Context, *CarriageDailyPageInfo) (*CarriageDailyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCarriageDailyList not implemented")
}
func (UnimplementedCarriageServer) GetCarriageDaily(context.Context, *CarriageDailyRequest) (*CarriageDailyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCarriageDaily not implemented")
}
func (UnimplementedCarriageServer) GetCarriageList(context.Context, *CarriagePageInfo) (*CarriageListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCarriageList not implemented")
}
func (UnimplementedCarriageServer) GetCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCarriage not implemented")
}
func (UnimplementedCarriageServer) CreateCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCarriage not implemented")
}
func (UnimplementedCarriageServer) UpdateCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCarriage not implemented")
}
func (UnimplementedCarriageServer) DeleteCarriage(context.Context, *CarriageRequest) (*CarriageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCarriage not implemented")
}
func (UnimplementedCarriageServer) GetCarriageDailyListByDate(context.Context, *CarriageDailyPageInfo) (*CarriageDailyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCarriageDailyListByDate not implemented")
}
func (UnimplementedCarriageServer) GetAllCarriage(context.Context, *CarriageRequest) (*CarriageListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCarriage not implemented")
}
func (UnimplementedCarriageServer) GenerateCarriageDaily(context.Context, *CarriageDailyRequest) (*CarriageListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCarriageDaily not implemented")
}
func (UnimplementedCarriageServer) mustEmbedUnimplementedCarriageServer() {}

// UnsafeCarriageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CarriageServer will
// result in compilation errors.
type UnsafeCarriageServer interface {
	mustEmbedUnimplementedCarriageServer()
}

func RegisterCarriageServer(s grpc.ServiceRegistrar, srv CarriageServer) {
	s.RegisterService(&Carriage_ServiceDesc, srv)
}

func _Carriage_GetCarriageDailyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageDailyPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GetCarriageDailyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GetCarriageDailyList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GetCarriageDailyList(ctx, req.(*CarriageDailyPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_GetCarriageDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GetCarriageDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GetCarriageDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GetCarriageDaily(ctx, req.(*CarriageDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_GetCarriageList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriagePageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GetCarriageList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GetCarriageList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GetCarriageList(ctx, req.(*CarriagePageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_GetCarriage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GetCarriage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GetCarriage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GetCarriage(ctx, req.(*CarriageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_CreateCarriage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).CreateCarriage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_CreateCarriage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).CreateCarriage(ctx, req.(*CarriageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_UpdateCarriage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).UpdateCarriage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_UpdateCarriage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).UpdateCarriage(ctx, req.(*CarriageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_DeleteCarriage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).DeleteCarriage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_DeleteCarriage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).DeleteCarriage(ctx, req.(*CarriageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_GetCarriageDailyListByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageDailyPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GetCarriageDailyListByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GetCarriageDailyListByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GetCarriageDailyListByDate(ctx, req.(*CarriageDailyPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_GetAllCarriage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GetAllCarriage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GetAllCarriage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GetAllCarriage(ctx, req.(*CarriageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Carriage_GenerateCarriageDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CarriageDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarriageServer).GenerateCarriageDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Carriage_GenerateCarriageDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarriageServer).GenerateCarriageDaily(ctx, req.(*CarriageDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Carriage_ServiceDesc is the grpc.ServiceDesc for Carriage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Carriage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Carriage",
	HandlerType: (*CarriageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCarriageDailyList",
			Handler:    _Carriage_GetCarriageDailyList_Handler,
		},
		{
			MethodName: "GetCarriageDaily",
			Handler:    _Carriage_GetCarriageDaily_Handler,
		},
		{
			MethodName: "GetCarriageList",
			Handler:    _Carriage_GetCarriageList_Handler,
		},
		{
			MethodName: "GetCarriage",
			Handler:    _Carriage_GetCarriage_Handler,
		},
		{
			MethodName: "CreateCarriage",
			Handler:    _Carriage_CreateCarriage_Handler,
		},
		{
			MethodName: "UpdateCarriage",
			Handler:    _Carriage_UpdateCarriage_Handler,
		},
		{
			MethodName: "DeleteCarriage",
			Handler:    _Carriage_DeleteCarriage_Handler,
		},
		{
			MethodName: "GetCarriageDailyListByDate",
			Handler:    _Carriage_GetCarriageDailyListByDate_Handler,
		},
		{
			MethodName: "GetAllCarriage",
			Handler:    _Carriage_GetAllCarriage_Handler,
		},
		{
			MethodName: "GenerateCarriageDaily",
			Handler:    _Carriage_GenerateCarriageDaily_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "train.proto",
}

const (
	Seat_GetSeatDailyByTrainCode_FullMethodName = "/proto.Seat/GetSeatDailyByTrainCode"
	Seat_GetSeatList_FullMethodName             = "/proto.Seat/GetSeatList"
	Seat_GetSeat_FullMethodName                 = "/proto.Seat/GetSeat"
	Seat_UpdateSeat_FullMethodName              = "/proto.Seat/UpdateSeat"
	Seat_DeleteSeat_FullMethodName              = "/proto.Seat/DeleteSeat"
	Seat_GenerateSeatDaily_FullMethodName       = "/proto.Seat/GenerateSeatDaily"
)

// SeatClient is the client API for Seat service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SeatClient interface {
	// rpc GetSeatDailyList(SeatDailyPageInfo) returns (SeatDailyListResponse);
	GetSeatDailyByTrainCode(ctx context.Context, in *SeatDailyRequest, opts ...grpc.CallOption) (*SeatDailyResponse, error)
	GetSeatList(ctx context.Context, in *SeatPageInfo, opts ...grpc.CallOption) (*SeatListResponse, error)
	GetSeat(ctx context.Context, in *SeatRequest, opts ...grpc.CallOption) (*SeatResponse, error)
	// rpc CreateSeat(SeatRequest) returns (SeatResponse);
	UpdateSeat(ctx context.Context, in *SeatRequest, opts ...grpc.CallOption) (*SeatResponse, error)
	DeleteSeat(ctx context.Context, in *SeatRequest, opts ...grpc.CallOption) (*SeatResponse, error)
	// rpc GetSeatDailyListByDate(SeatDailyPageInfo) returns (SeatDailyListResponse);
	// rpc GetAllSeat(SeatRequest) returns (SeatListResponse);
	GenerateSeatDaily(ctx context.Context, in *SeatDailyRequest, opts ...grpc.CallOption) (*SeatListResponse, error)
}

type seatClient struct {
	cc grpc.ClientConnInterface
}

func NewSeatClient(cc grpc.ClientConnInterface) SeatClient {
	return &seatClient{cc}
}

func (c *seatClient) GetSeatDailyByTrainCode(ctx context.Context, in *SeatDailyRequest, opts ...grpc.CallOption) (*SeatDailyResponse, error) {
	out := new(SeatDailyResponse)
	err := c.cc.Invoke(ctx, Seat_GetSeatDailyByTrainCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) GetSeatList(ctx context.Context, in *SeatPageInfo, opts ...grpc.CallOption) (*SeatListResponse, error) {
	out := new(SeatListResponse)
	err := c.cc.Invoke(ctx, Seat_GetSeatList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) GetSeat(ctx context.Context, in *SeatRequest, opts ...grpc.CallOption) (*SeatResponse, error) {
	out := new(SeatResponse)
	err := c.cc.Invoke(ctx, Seat_GetSeat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) UpdateSeat(ctx context.Context, in *SeatRequest, opts ...grpc.CallOption) (*SeatResponse, error) {
	out := new(SeatResponse)
	err := c.cc.Invoke(ctx, Seat_UpdateSeat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) DeleteSeat(ctx context.Context, in *SeatRequest, opts ...grpc.CallOption) (*SeatResponse, error) {
	out := new(SeatResponse)
	err := c.cc.Invoke(ctx, Seat_DeleteSeat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) GenerateSeatDaily(ctx context.Context, in *SeatDailyRequest, opts ...grpc.CallOption) (*SeatListResponse, error) {
	out := new(SeatListResponse)
	err := c.cc.Invoke(ctx, Seat_GenerateSeatDaily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SeatServer is the server API for Seat service.
// All implementations must embed UnimplementedSeatServer
// for forward compatibility
type SeatServer interface {
	// rpc GetSeatDailyList(SeatDailyPageInfo) returns (SeatDailyListResponse);
	GetSeatDailyByTrainCode(context.Context, *SeatDailyRequest) (*SeatDailyResponse, error)
	GetSeatList(context.Context, *SeatPageInfo) (*SeatListResponse, error)
	GetSeat(context.Context, *SeatRequest) (*SeatResponse, error)
	// rpc CreateSeat(SeatRequest) returns (SeatResponse);
	UpdateSeat(context.Context, *SeatRequest) (*SeatResponse, error)
	DeleteSeat(context.Context, *SeatRequest) (*SeatResponse, error)
	// rpc GetSeatDailyListByDate(SeatDailyPageInfo) returns (SeatDailyListResponse);
	// rpc GetAllSeat(SeatRequest) returns (SeatListResponse);
	GenerateSeatDaily(context.Context, *SeatDailyRequest) (*SeatListResponse, error)
	mustEmbedUnimplementedSeatServer()
}

// UnimplementedSeatServer must be embedded to have forward compatible implementations.
type UnimplementedSeatServer struct {
}

func (UnimplementedSeatServer) GetSeatDailyByTrainCode(context.Context, *SeatDailyRequest) (*SeatDailyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeatDailyByTrainCode not implemented")
}
func (UnimplementedSeatServer) GetSeatList(context.Context, *SeatPageInfo) (*SeatListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeatList not implemented")
}
func (UnimplementedSeatServer) GetSeat(context.Context, *SeatRequest) (*SeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeat not implemented")
}
func (UnimplementedSeatServer) UpdateSeat(context.Context, *SeatRequest) (*SeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSeat not implemented")
}
func (UnimplementedSeatServer) DeleteSeat(context.Context, *SeatRequest) (*SeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSeat not implemented")
}
func (UnimplementedSeatServer) GenerateSeatDaily(context.Context, *SeatDailyRequest) (*SeatListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSeatDaily not implemented")
}
func (UnimplementedSeatServer) mustEmbedUnimplementedSeatServer() {}

// UnsafeSeatServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SeatServer will
// result in compilation errors.
type UnsafeSeatServer interface {
	mustEmbedUnimplementedSeatServer()
}

func RegisterSeatServer(s grpc.ServiceRegistrar, srv SeatServer) {
	s.RegisterService(&Seat_ServiceDesc, srv)
}

func _Seat_GetSeatDailyByTrainCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).GetSeatDailyByTrainCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Seat_GetSeatDailyByTrainCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).GetSeatDailyByTrainCode(ctx, req.(*SeatDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_GetSeatList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatPageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).GetSeatList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Seat_GetSeatList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).GetSeatList(ctx, req.(*SeatPageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_GetSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).GetSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Seat_GetSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).GetSeat(ctx, req.(*SeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_UpdateSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).UpdateSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Seat_UpdateSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).UpdateSeat(ctx, req.(*SeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_DeleteSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).DeleteSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Seat_DeleteSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).DeleteSeat(ctx, req.(*SeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_GenerateSeatDaily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatDailyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).GenerateSeatDaily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Seat_GenerateSeatDaily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).GenerateSeatDaily(ctx, req.(*SeatDailyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Seat_ServiceDesc is the grpc.ServiceDesc for Seat service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Seat_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Seat",
	HandlerType: (*SeatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSeatDailyByTrainCode",
			Handler:    _Seat_GetSeatDailyByTrainCode_Handler,
		},
		{
			MethodName: "GetSeatList",
			Handler:    _Seat_GetSeatList_Handler,
		},
		{
			MethodName: "GetSeat",
			Handler:    _Seat_GetSeat_Handler,
		},
		{
			MethodName: "UpdateSeat",
			Handler:    _Seat_UpdateSeat_Handler,
		},
		{
			MethodName: "DeleteSeat",
			Handler:    _Seat_DeleteSeat_Handler,
		},
		{
			MethodName: "GenerateSeatDaily",
			Handler:    _Seat_GenerateSeatDaily_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "train.proto",
}
